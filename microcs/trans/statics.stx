module statics

imports
  signatures/microcs-sig

signature
  sorts TYPE constructors
    CLASS       : string * scope -> TYPE
    OBJECT      : TYPE * scope -> TYPE
    INT         : TYPE
    BOOL        : TYPE
    OBJECT      : TYPE
    NULL        : TYPE
    METHOD      : list(TYPE) * TYPE -> TYPE
  sorts
    DECL = (path * (occurrence * TYPE))

signature
  namespaces
    Class       : ID
    Member      : ID
    Var         : ID
    Constructor :

  relations
    type        : occurrence -> TYPE

  name-resolution
    labels
      P     // lexical parent
      S     // static parent

rules programOk : Start
  programOk(Program(classes)) :- {s}
    new s,
    init(s),
    classesOk(s, classes).

rules init : scope
  init(s) :-
      classOk(s, Class("Math", [
        StaticMethod(IntType(), "Max",
          [Param(IntType(), "x"), Param(IntType(), "y")], [],
          Cond(
            Lt(Ref2Exp(Var("x")), Ref2Exp(Var("y"))),
            Ref2Exp(Var("y")),
            Ref2Exp(Var("x"))
          )
        )
      ])
    ).

rules classOk : scope * ClassDecl
  classesOk maps classOk(*, list(*))

  classOk(globalScope, Class(name, members)) :- {cs is CT IT}
    // Static class
    new cs, cs -P-> globalScope,
    CT == CLASS(name, cs),
    declareClass(globalScope, name, CT),

    // Instance object
    new is, is -P-> globalScope,
    IT == OBJECT(CT, is),

    declareVarOccurrence(is, Var{"this"@name}, IT),
    declareConstructor(cs, IT),
    membersOk(cs, is, members).

rules memberOk : scope * scope * MemberDecl
  membersOk maps memberOk(*, *, list(*))

  memberOk(cs, is, InstanceField(type, name)) :- {T}
    typeOfObjectType(cs, type) == T,
    declareInstanceMember(is, cs, name, T).

  memberOk(cs, is,
      InstanceMethod(returnType, name, params, stmts, returnExp)
  ) :- {ms RT PTS T}
    new ms, ms -P-> is,
    typeOfObjectType(cs, returnType) == RT,
    typesOfParams(ms, params) == PTS,
    declareInstanceMember(is, cs, name, METHOD(PTS, RT)),
    typeOfExp(ms, returnExp) == RT,
    stmtsOk(ms, stmts).

  memberOk(cs, _,
      StaticMethod(returnType, name, params, stmts, returnExp)
  ) :- {ms RT PTS T}
    new ms, ms -P-> cs,
    typeOfObjectType(cs, returnType) == RT,
    typesOfParams(ms, params) == PTS,
    declareStaticMember(cs, name, METHOD(PTS, RT)),
    typeOfExp(ms, returnExp) == RT,
    stmtsOk(ms, stmts).

rules typeOfParam : scope * ParamDecl -> TYPE
  typesOfParams maps typeOfParam(*, list(*)) = list(*)

  typeOfParam(s, Param(type, name)) = T :-
    typeOfObjectType(s, type) == T,
    declareVar(s, name, T).

rules stmtOk : scope * Stmt
  stmtsOk maps stmtOk(*, list(*))

  stmtOk(bs, Block(stmts)) :- {nbs}
    new nbs, nbs -P-> bs,
    stmtsOk(nbs, stmts).

  stmtOk(_, Nop()).

  stmtOk(bs, Exp(e)) :-
    typeOfExp(bs, e) == _.

  stmtOk(bs, DeclareTypedVar(type, name)) :- {T}
    typeOfObjectType(bs, type) == T,
    declareVar(bs, name, T).

  stmtOk(bs, DeclareTypedVarInit(type, name, e)) :- {T}
    typeOfObjectType(bs, type) == T,
    typeOfExp(bs, e) == T,
    declareVar(bs, name, T).

  stmtOk(bs, DeclareVarInit(name, e)) :- {T}
    typeOfExp(bs, e) == T,
    declareVar(bs, name, T).

  stmtOk(bs, Assign(name, e)) :- {T}
    typeOfExp(bs, e) == T,
    typeOfVarMemberClass(bs, name) == T.

rules typeOfExp : scope * Exp -> TYPE
  typesOfExps maps typeOfExp(*, list(*)) = list(*)

  typeOfExp(s, Ref2Exp(ref))            = typeOfRef(s, ref).

  typeOfExp(s, e@Call(_, _))            = typeOfCall(s, e).
  typeOfExp(s, e@Call(Member(_, _), _)) = typeOfCall(s, e).
  typeOfExp(s, e@Call(Ref2Exp(_), _))   = typeOfCall(s, e).

  typeOfExp(s, e@New(_))                = typeOfNew(s, e).
  typeOfExp(s, e@New(ClassType(_)))     = typeOfNew(s, e).

  typeOfExp(s, Member(e, name)) = T :- {T1 ms}
    typeOfExp(s, e) == T1,
    getScope(T1) == ms,
    typeOfMember(ms, name) == T.

  typeOfExp(_, Null())  = NULL().
  typeOfExp(_, True())  = BOOL().
  typeOfExp(_, False()) = BOOL().

  typeOfExp(s, Lt(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == INT(),
    typeOfExp(s, e2) == INT().

  typeOfExp(s, Eq(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == _,
    typeOfExp(s, e2) == _.

  typeOfExp(s, Neq(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == _,
    typeOfExp(s, e2) == _.

  typeOfExp(s, And(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == BOOL(),
    typeOfExp(s, e2) == BOOL().

  typeOfExp(s, Not(e1)) = BOOL() :-
    typeOfExp(s, e1) == BOOL().

  typeOfExp(s, Int(_)) = INT().

  typeOfExp(s, Mul(e1, e2)) = INT() :-
    typeOfExp(s, e1) == INT(),
    typeOfExp(s, e2) == INT().

  typeOfExp(s, Add(e1, e2)) = T :-
    typeOfExp(s, e1) == INT(),
    typeOfExp(s, e2) == INT().

  typeOfExp(s, Cond(ec, e1, e2)) = T :- {T1 T2}
    typeOfExp(s, ec) == BOOL(),
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    lub(T1, T2) == T.

rules typeOfRef : scope * Ref -> TYPE
  typesOfRefs maps typeOfRef(*, list(*)) = list(*)

  typeOfRef(s, Var(name)) = T :-
    typeOfVarMemberClass(s, name) == T.

  typeOfRef(s, This()) = T :- {decl}
    resolveVar(s, "this") == [(_, (decl, T))|_].

rules typeOfCall : scope * Exp -> TYPE
  typeOfCall(s, Call(e, args)) = TR :- {TA}
    typeOfExp(s, e) == METHOD(TA, TR),
    typesOfExps(s, args) == TA.

rules typeOfNew : scope * Exp -> TYPE
  typeOfNew(s, New(type)) = T :- {cs name}
    typeOfType(s, type) == CLASS(name, cs),
    typeOfConstructor(cs, name) == T.

rules getScope : TYPE -> scope
  getScope(OBJECT(_, is)) = is.
  getScope(CLASS(_, cs)) = cs.

// Static type
rules typeOfType : scope * Type -> TYPE
  typeOfType(s, t@IntType())          = INT().
  typeOfType(s, t@BoolType())         = BOOL().
  typeOfType(s, t@ObjectType())       = OBJECT().
  typeOfType(s, t@ClassType(name))    = typeOfClass(s, name).

// Instance type
rules typeOfObjectType : scope * Type -> TYPE
  typeOfObjectType(s, t@IntType())    = INT().
  typeOfObjectType(s, t@BoolType())   = BOOL().
  typeOfObjectType(s, t@ObjectType()) = OBJECT().

  typeOfObjectType(s, t@ClassType(name)) = T :- {cs}
    typeOfClass(s, name) == CLASS(_, cs),
    typeOfConstructor(cs, name) == T.

rules lub : TYPE * TYPE -> TYPE

  lub(T@OBJECT(CLASS(_, _), _), NULL()) = T.
  lub(NULL(), T@OBJECT(CLASS(_, _), _)) = T.
  lub(T,      T)                        = T.

// Classes
rules declareClass : scope * ID * TYPE
  declareClass(s, decl, T) :-
    !type[Class{decl@decl}, T] in s.

rules resolveClass : scope * ID -> list(DECL)
  resolveClass(s, name) = ps :-
    query type
      filter P*
      and { d' :- d' == Class{name@_} }
      min $ < P
      in s |-> ps.

rules typeOfClass : scope * ID -> TYPE
  typeOfClass(s, name) = T :- {decl}
    resolveClass(s, name) == [(_, (decl, T))|_].

// Variables
rules declareVarOccurrence : scope * occurrence * TYPE
  declareVarOccurrence(s, occ@Var{name@_}, T) :-
    !type[occ, T] in s.

rules declareVar : scope * ID * TYPE
  declareVar(s, decl, T) :-
    declareVarOccurrence(s, Var{decl@decl}, T).

rules resolveVar : scope * ID -> list(DECL)
  resolveVar(s, name) = ps :-
    query type
      filter P*
      and { d' :- d' == Var{name@_} }
      min $ < P
      in s |-> ps.

rules typeOfVar : scope * ID -> TYPE
  typeOfVar(s, name) = T :- {decl}
    resolveVar(s, name) == [(_, (decl, T))|_].

rules resolveVarMemberClass : scope * ID -> list(DECL)
  resolveVarMemberClass(s, name)
    = unwrapVarMemberClass(s, name, resolveVar(s, ref)).

rules unwrapVarMemberClass : scope * ID * list(DECL) -> list(DECL)
  unwrapVarMemberClass(_, _, ps@[(_, (Var{decl@_}, T))|_]) = ps.
  unwrapVarMemberClass(s, name, []) = resolveMemberClass(s, name).

rules typeOfVarMemberClass : scope * ID -> TYPE
  typeOfVarMemberClass(s, name) = T :- {decl}
    // resolution order:
    // 1. variables
    // 2. member (instance or static)
    // 3. type
    resolveVarMemberClass(s, name) == [(_, (decl, T))|_].

rules resolveMemberClass : scope * ID -> list(DECL)
  resolveMemberClass(s, name)
    = unwrapMemberClass(s, name, resolveStaticOrInstanceMember(s, ref)).

rules unwrapMemberClass : scope * ID * list(DECL) -> list(DECL)
  unwrapMemberClass(_, _, ps@[(_, (Member{decl@_}, T))|_]) = ps.
  unwrapMemberClass(s, name, []) = resolveClass(s, name).

rules typeOfMemberClass : scope * ID -> TYPE
  typeOfMemberClass(s, name) = T :- {decl}
    // resolution order:
    // 1. member (instance or static)
    // 2. type
    resolveMemberClass(s, name) == [(_, (decl, T))|_].

// Constructors
rules declareConstructor : scope * TYPE
  declareConstructor(cs, T) :-
    !type[Constructor{}, T] in cs.

rules resolveConstructor : scope -> list(DECL)
  resolveConstructor(cs) = ps :-
    query type
      filter P*
      and { d' :- d' == Constructor{} }
      min $ < P
      in cs |-> ps.

rules typeOfConstructor : scope * ID -> TYPE
  typeOfConstructor(cs, name) = T :-
    resolveConstructor(cs) == [(_, (_, T@OBJECT(CLASS(name, _), _)))|_].

// Members
rules declareInstanceMember : scope * scope * ID * TYPE
  declareInstanceMember(is, cs, decl, T) :-
    !type[Member{decl@decl}, T] in is.

rules declareStaticMember : scope * ID * TYPE
  declareStaticMember(cs, decl, T) :-
    !type[Member{decl@decl}, T] in cs.

rules resolveMember : scope * ID -> list((path * (occurrence * TYPE)))
  resolveMember(s, ref) = ps :-
    query type
      filter P*
      and { d' :- d' == Member{ref@_} }
      min $ < P
      in s |-> ps.

rules resolveStaticOrInstanceMember : scope * ID -> list(DECL)
  resolveStaticOrInstanceMember(s, ref) = ps :-
    query type
      filter P* S?
      and { d' :- d' == Member{ref@_} }
      min $ < P, $ < S, P < S
      in s |-> ps.

rules typeOfMember : scope * ID -> TYPE
  typeOfMember(s, name) = T :- {decl}
    resolveMember(s, name) == [(_, (decl, T))|_].

rules
  programOk(Start-Plhdr()).
  classOk(_, ClassDecl-Plhdr()).
  memberOk(_, _, MemberDecl-Plhdr()).
  typeOfParam(_, ParamDecl-Plhdr()) = _.
  stmtOk(_, Stmt-Plhdr()).
  typeOfExp(_, Exp-Plhdr()) = _.
  typeOfRef(_, Ref-Plhdr()) = _.
  typeOfType(_, Type-Plhdr()) = _.
  typeOfObjectType(_, Type-Plhdr()) = _.
