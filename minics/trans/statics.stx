module statics

imports
//  signatures/Common-sig
  signatures/minics-sig

signature
  sorts TYPE constructors
    CLASS       : string * scope -> TYPE
    INT         : TYPE
    BOOL        : TYPE
    VOID        : TYPE
    // TODO: Add receiver type?
    METHOD      : list(TYPE) * TYPE -> TYPE

  namespaces
    Class       : ID
    Member      : ID
//    Field       : ID
//    Method      : ID
    Var         : ID
    Return      :

  relations
    type        : occurrence -> TYPE

  name-resolution
    labels
      P     // lexical parent
      S     // super class
      I     // import (using)
    resolve Class  filter P*I? min $ < P, $ < I, P < I      // prefer lexical parents over imports
    resolve Member filter P*S* min $ < P, $ < S, S < P      // prefer super classes over lexical parents
    resolve Var    filter P* min $ < P
    resolve Return filter P* min $ < P

rules usingOk : scope * UsingDecl
  usingsOk maps usingOk(*, list(*))

  usingOk(s, u).

rules mainClassOk : scope * MainClassDecl

  mainClassOk(globalScope, class@MainClass(name, stmts)) :- {classScope methodScope T}
    new classScope,
    classScope -P-> globalScope,
    T == CLASS(name, classScope),
    globalScope -> Class{name@name} with type T,

    new methodScope,
    methodScope -P-> classScope,
    stmtsOk(methodScope, stmts),
    @class.type := T.


rules classOk : scope * ClassDecl
  classesOk maps classOk(*, list(*))

  classOk(globalScope, class@Class(name, parent, members)) :- {classScope methodScope T}
    new classScope,
    classScope -P-> globalScope,
    T == CLASS(name, classScope),
    globalScope -> Class{name@name} with type T,
    classScope -> Var{"this"@name} with type T,
    parentOk(classScope, parent),
    membersOk(classScope, members),
    @class.type := T.

rules parentOk : scope * ParentDecl

  parentOk(classScope, parent@NoParent()) :-
    // TODO: Inherit from Object.
    true.

  parentOk(classScope, parent@Parent(ref)) :- {parentScope T}
    typeOfClass(classScope, ref) == T@CLASS(_, parentScope),
    // Ensure the parents are different from the class itself
    query () filter P*S* and { ancestorScope :- ancestorScope == classScope }
      min $ < P, $ < S, S < P
      in parentScope |-> [] | error $[cyclic inheritance],
    classScope -S-> parentScope,
    classScope -> Var{"base"@ref} with type T,
    @parent.type := T.

rules memberOk : scope * MemberDecl
  membersOk maps memberOk(*, list(*))

  memberOk(classScope, Field(type, name)) :- {T}
    typeOfType(classScope, type) == T,
    classScope -> Member{name@name} with type T,
    @name.type := T.

  memberOk(classScope, Method(returnType, name, params, stmts)) :- {methodScope RT PTS T}
    new methodScope,
    methodScope -P-> classScope,
    typeOfType(classScope, returnType) == RT,
    typesOfParams(methodScope, params) == PTS,
    T == METHOD(PTS, RT),
    classScope -> Member{name@name} with type T,
    methodScope -> Return{@name} with type RT,
    stmtsOk(methodScope, stmts),
    @name.type := T.

rules stmtOk : scope * Stmt
  stmtsOk maps stmtOk(*, list(*))

  stmtOk(blockScope, Block(stmts)) :- {nestedBlockScope}
    new nestedBlockScope,
    nestedBlockScope -P-> blockScope,
    stmtsOk(nestedBlockScope, stmts).

//  stmtOk(blockScope, Seq(stm1, stm2)) :-
//    stmtOk(blockScope, stm1),
//    stmtOk(blockScope, stm2).

  stmtOk(blockScope, Nop()).

  stmtOk(blockScope, Exp(e)) :-
    typeOfExp(blockScope, e) == _.

  stmtOk(blockScope, DeclareTypedVar(type, name)) :- {T}
    typeOfType(blockScope, type) == T,
    // FIXME: Variable should only be declared in subsequent scopes
    blockScope -> Var{name@name} with type T,
    @name.type := T.

  stmtOk(blockScope, DeclareTypedVarInit(type, name, e)) :- {T TE}
    typeOfType(blockScope, type) == T,
    typeOfExp(blockScope, e) == TE,
    T == TE | error $[expected [T], got [TE]],
    // FIXME: Variable should only be declared in subsequent scopes
    blockScope -> Var{name@name} with type T,
    @name.type := T.

  stmtOk(blockScope, DeclareVarInit(name, e)) :- {T}
    typeOfExp(blockScope, e) == T,
    // FIXME: Variable should only be declared in subsequent scopes
    blockScope -> Var{name@name} with type T,
    @name.type := T.

  stmtOk(blockScope, Assign(name, e)) :- {TE TV}
    typeOfExp(blockScope, e) == TE,
    typeOfVarOrMember(blockScope, name) == TV,
    TV == TE | error $[expected [TV], got [TE]],
    @name.type := TV.

  stmtOk(blockScope, stmt@If(condExp, thenStmt, elseStmt)) :- {TC}
    typeOfExp(blockScope, condExp) == TC,
    TC == BOOL() | error $[expected bool, got [TC]],
    stmtOk(blockScope, thenStmt),
    stmtOk(blockScope, elseStmt),
    @stmt.type := TC.

  stmtOk(blockScope, Return(e)) :- {T TR}
    typeOfExp(blockScope, e) == T,
    type of Return{@-} in blockScope |-> [(_, (Return{@_}, TR))],
    TR != VOID() | error $[expected void, got [TR]],
    TR == T | error $[expected [TR], got [T]].

rules typeOfType : scope * Type -> TYPE

  typeOfType(s, t@Int()) = T :-
    T == INT(),
    @t.type := T.

  typeOfType(s, t@Bool()) = T :-
    T == BOOL(),
    @t.type := T.

  typeOfType(s, t@Void()) = T :-
    T == VOID(),
    @t.type := T.

  typeOfType(s, t@ClassType(ref)) = T :- {decl}
    type of Class{ref} in s |-> [(_, (Class{decl}, T))],
    @ref.ref := decl,
    @t.type := T.

rules typeOfParam : scope * ParamDecl -> TYPE
  typesOfParams maps typeOfParam(*, list(*)) = list(*)

  typeOfParam(s, Param(type, name)) = T :-
    typeOfType(s, type) == T,
    s -> Var{name@name} with type T,
    @name.type := T.

rules typeOfExp : scope * Exp -> TYPE

  typesOfExps maps typeOfExp(*, list(*)) = list(*)

  typeOfExp(s, e@Var(ref)) = T :- {decl}
    typeOfVarOrMember(s, ref) == T,
    @e.type := T.

  typeOfExp(s, e@This()) = T :- {decl}
    type of Var{"this"@-} in s |-> [(_, (Var{decl@_}, T))],
    @e.ref := decl,
    @e.type := T.

  typeOfExp(s, e@Base()) = T :- {decl}
    type of Var{"base"@-} in s |-> [(_, (Var{decl@_}, T))],
    @e.ref := decl,
    @e.type := T.

  typeOfExp(s, e@Call(e1, args)) = TR :- {T1 TPARAMS TARGS}
    typeOfExp(s, e1) == T1,
    T1 == METHOD(TPARAMS, TR) | error $[expected method, got [T1]],
    typesOfExps(s, args) == TARGS,
    TARGS == TPARAMS | error $[expected parameters of types [TPARAMS], got [TARGS]],
    @e.type := TR.

  typeOfExp(s, e@New(ref)) = T :- {decl}
    type of Class{ref} in s |-> [(_, (Class{decl@_}, T))],
    @ref.ref := decl,
    @e.type := T.

  typeOfExp(s, e@Member(e1, ref)) = T :- {T1 classScope decl}
    typeOfExp(s, e1) == T1,
    T1 == CLASS(_, classScope),
    type of Member{ref@-} in classScope |-> [(_, (Member{decl@_}, T))],
    @ref.ref := decl,
    @e.type := T.

  typeOfExp(_, e@True()) = T :-
    T == BOOL(),
    @e.type := T.

  typeOfExp(_, e@False()) = T :-
    T == BOOL(),
    @e.type := T.

  typeOfExp(s, e@Lt(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Le(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Gt(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Ge(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Eq(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == T2 | error $[expected [T1], got [T2]].

  typeOfExp(s, e@Neq(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == T2 | error $[expected [T1], got [T2]].

  typeOfExp(s, e@And(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == BOOL() | error $[expected bool, got [T1]],
    T2 == BOOL() | error $[expected bool, got [T2]].

  typeOfExp(s, e@Or(e1, e2)) = T :- {T1 T2}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == BOOL() | error $[expected bool, got [T1]],
    T2 == BOOL() | error $[expected bool, got [T2]].

  typeOfExp(s, e@Not(e1)) = T :- {T1}
    T == BOOL(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    T1 == BOOL() | error $[expected bool, got [T1]].

  typeOfExp(s, e@Int(_)) = T :-
    T == INT(),
    @e.type := T.

  typeOfExp(s, e@Plus(e1)) = T :- {T1}
    T == INT(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    T1 == INT() | error $[expected int, got [T1]].

  typeOfExp(s, e@Min(e1)) = T :- {T1}
    T == INT(),
    @e.type := T,
    typeOfExp(s, e1) == T,
    T1 == INT() | error $[expected int, got [T1]].

  typeOfExp(s, e@Mul(e1, e2)) = T :- {T1 T2}
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Div(e1, e2)) = T :- {T1 T2}
    T == INT(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Add(e1, e2)) = T :- {T1 T2}
    T == INT(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Sub(e1, e2)) = T :- {T1 T2}
    T == INT(),
    @e.type := T,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    T1 == INT() | error $[expected int, got [T1]],
    T2 == INT() | error $[expected int, got [T2]].

  typeOfExp(s, e@Cond(c, e1, e2)) = T :- {TC T1 T2}
    typeOfExp(s, c) == TC,
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    TC == BOOL() | error $[expected bool, got [TC]],
    T1 == T2 | error $[expected [T1], got [T2]],
    T1 == T,
    @e.type := T.

rules typeOfVarOrMember : scope * ID -> TYPE

  typeOfVarOrMember(s, ref) = T :- {p decl}
    type of Var{ref@-} in s |-> p,
    unwrapVarOrResolveMember(s, ref, p) == (decl, T),
    @ref.ref := decl.

rules typeOfField : scope * ID -> TYPE

  typeOfField(s, ref) = T :- {decl}
    resolveMember(s, ref) == (decl, T),
    @ref.ref := decl.

rules typeOfClass : scope * ID -> TYPE

  typeOfClass(s, ref) = T :- {decl}
    resolveClass(s, ref) == (decl, T),
    @ref.ref := decl.

rules resolveClass : scope * ID -> (ID * TYPE)

  resolveClass(s, ref) = (decl, T) :-
    type of Class{ref@-} in s |-> [(_, (Class{decl@_}, T))].

rules resolveVarOrMember : scope * ID -> (ID * TYPE)

  resolveVarOrMember(s, ref) = (decl, T) :- {p}
    type of Var{ref@-} in s |-> p,
    unwrapVarOrResolveMember(s, ref, p) == (decl, T).

rules resolveMember : scope * ID -> (ID * TYPE)

  resolveMember(s, ref) = (decl, T) :-
    type of Member{ref@-} in s |-> [(_, (Member{decl@_}, T))].

rules unwrapVarOrResolveMember : scope * ID * list((path * (occurrence * TYPE))) -> (ID * TYPE)

  unwrapVarOrResolveMember(_, _, [(_, (Var{decl@_}, T))]) = (decl, T).
  unwrapVarOrResolveMember(s, ref, []) = resolveMember(s, ref).

// Single-file entry point
rules programOk : Start

  programOk(Program(usings, mainClass, classes)) :- {s}
    new s,
    init(s),
    usingsOk(s, usings),
    mainClassOk(s, mainClass),
    classesOk(s, classes).

// Multi-file entry point
rules projectOk : scope

  projectOk(s).

rules fileOk : scope * Start

  fileOk(s, _).

rules init : scope

  init(s).
