module statics

imports
  signatures/microcs-sig

signature
  sorts TYPE 
  constructors
    CLASS       : string * scope -> TYPE
    METHOD      : list(TYPE) * TYPE -> TYPE
    INT         : TYPE
    BOOL        : TYPE
    OBJECT      : TYPE
    NULL        : TYPE
    VOID        : TYPE
  sorts
    DECL = (path * (occurrence * TYPE))

signature
  namespaces
    Class       : ID
    Member      : ID
    Var         : ID

  relations
    type        : occurrence -> TYPE

  name-resolution
    labels
      P     // lexical parent

rules programOk : Start
  programOk(Program(classes)) :- {s}
    new s,
    init(s),
    classesOk(s, classes).

rules init : scope
  init(s) :-
    classOk(s, Class("Exception", [])).

rules classOk : scope * ClassDecl
  classesOk maps classOk(*, list(*))

  classOk(s, Class(name, members)) :- {cs T}
    new cs, cs -P-> s,
    T == CLASS(name, cs),
    declareClass(s, name, T),

    declareVarOccurrence(cs, Var{"this"@name}, T),
    membersOk(cs, members).

rules memberOk : scope * MemberDecl
  membersOk maps memberOk(*, list(*))

  memberOk(cs, Field(type, name)) :- {T}
    typeOfType(cs, type) == T,
    declareMember(cs, name, T).

  memberOk(cs, Method(returnType, name, params, stmts, finalStmt)) :- {ms RT PTS RTE T}
    new ms, ms -P-> cs,
    typeOfType(cs, returnType) == RT,
    typesOfParams(ms, params) == PTS,
    declareMember(cs, name, METHOD(PTS, RT)),
    finalStmtOk(ms, finalStmt, RT),
    stmtsOk(ms, stmts).

rules typeOfParam : scope * ParamDecl -> TYPE
  typesOfParams maps typeOfParam(*, list(*)) = list(*)

  typeOfParam(s, Param(type, name)) = T :-
    typeOfType(s, type) == T,
    declareVar(s, name, T).

rules finalStmtOk : scope * FinalStmt * TYPE
  finalStmtOk(s, Return(e), T) :- {TE}
    typeOfExp(s, e) == TE,
    assignableTo(TE, T).
  finalStmtOk(s, Throw(e), _) :- {T}
    typeOfExp(s, e) == T,
    assignableTo(T, CLASS("Exception", _)).
  finalStmtOk(s, NoReturn(), VOID()).


rules stmtOk : scope * Stmt
  stmtsOk maps stmtOk(*, list(*))

  stmtOk(bs, Block(stmts)) :- {nbs}
    new nbs, nbs -P-> bs,
    stmtsOk(nbs, stmts).

  stmtOk(_, Nop()).

  stmtOk(bs, Exp(e)) :-
    typeOfExp(bs, e) == _.

  stmtOk(bs, DeclareTypedVar(type, name)) :- {T}
    typeOfType(bs, type) == T,
    declareVar(bs, name, T).

  stmtOk(bs, DeclareTypedVarInit(type, name, e)) :- {T TE}
    typeOfType(bs, type) == T,
    typeOfExp(bs, e) == TE,
    assignableTo(TE, T),
    declareVar(bs, name, T).

  stmtOk(bs, DeclareVarInit(name, e)) :- {T}
    typeOfExp(bs, e) == T,
    declareVar(bs, name, T).

  stmtOk(bs, Assign(name, e)) :- {T TE}
    typeOfVarMemberClass(bs, name) == T,
    typeOfExp(bs, e) == TE,
    assignableTo(TE, T).

rules typeOfExp : scope * Exp -> TYPE
  typesOfExps maps typeOfExp(*, list(*)) = list(*)

  typeOfExp(s, Ref2Exp(ref))            = typeOfRef(s, ref).

  typeOfExp(s, e@Call(_, _))            = typeOfCall(s, e).
  typeOfExp(s, e@Call(Member(_, _), _)) = typeOfCall(s, e).
  typeOfExp(s, e@Call(Ref2Exp(_), _))   = typeOfCall(s, e).

  typeOfExp(s, e@New(_))                = typeOfNew(s, e).
  typeOfExp(s, e@New(ClassType(_)))     = typeOfNew(s, e).

  typeOfExp(s, Member(e, name)) = T :- {T1 cs}
    typeOfExp(s, e) == CLASS(_, cs),
    typeOfMember(cs, name) == T.

  typeOfExp(_, Null())  = NULL().
  typeOfExp(_, True())  = BOOL().
  typeOfExp(_, False()) = BOOL().

  typeOfExp(s, Lt(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == INT(),
    typeOfExp(s, e2) == INT().

  typeOfExp(s, Eq(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == _,
    typeOfExp(s, e2) == _.

  typeOfExp(s, Neq(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == _,
    typeOfExp(s, e2) == _.

  typeOfExp(s, And(e1, e2)) = BOOL() :-
    typeOfExp(s, e1) == BOOL(),
    typeOfExp(s, e2) == BOOL().

  typeOfExp(s, Not(e1)) = BOOL() :-
    typeOfExp(s, e1) == BOOL().

  typeOfExp(s, Int(_)) = INT().

  typeOfExp(s, Mul(e1, e2)) = INT() :-
    typeOfExp(s, e1) == INT(),
    typeOfExp(s, e2) == INT().

  typeOfExp(s, Add(e1, e2)) = INT() :-
    typeOfExp(s, e1) == INT(),
    typeOfExp(s, e2) == INT().

  typeOfExp(s, Cond(ec, e1, e2)) = T :- {T1 T2}
    typeOfExp(s, ec) == BOOL(),
    typeOfExp(s, e1) == T1,
    typeOfExp(s, e2) == T2,
    lub(T1, T2) == T.

rules typeOfRef : scope * Ref -> TYPE
  typesOfRefs maps typeOfRef(*, list(*)) = list(*)

  typeOfRef(s, Var(name)) = T :-
    typeOfVarMemberClass(s, name) == T.

  typeOfRef(s, This()) = T :- {decl}
    resolveVar(s, "this") == [(_, (decl, T))|_].

rules typeOfCall : scope * Exp -> TYPE
  typeOfCall(s, Call(e, args)) = TR :- {TA}
    typeOfExp(s, e) == METHOD(TA, TR),
    typesOfExps(s, args) == TA.

rules typeOfNew : scope * Exp -> TYPE
  typeOfNew(s, New(type)) = T :- {cs name}
    typeOfType(s, type) == T@CLASS(name, cs).

// Classes
rules declareClass : scope * ID * TYPE
  declareClass(s, decl, T) :-
    !type[Class{decl@decl}, T] in s.

rules resolveClass : scope * ID -> list(DECL)
  resolveClass(s, name) = ps :-
    query type
      filter P*
      and { d' :- d' == Class{name@_} }
      min $ < P
      in s |-> ps.

rules typeOfClass : scope * ID -> TYPE
  typeOfClass(s, name) = T :- {decl}
    resolveClass(s, name) == [(_, (decl, T))|_].

// Members
rules declareMember : scope * ID * TYPE
  declareMember(cs, decl, T) :-
    !type[Member{decl@decl}, T] in cs.

rules resolveMember : scope * ID -> list((path * (occurrence * TYPE)))
  resolveMember(s, name) = ps :-
    query type
      filter P*
      and { d' :- d' == Member{name@_} }
      min $ < P
      in s |-> ps.

rules typeOfMember : scope * ID -> TYPE
  typeOfMember(s, name) = T :- {decl}
    resolveMember(s, name) == [(_, (decl, T))|_].

// Variables
rules declareVarOccurrence : scope * occurrence * TYPE
  declareVarOccurrence(s, occ@Var{name@_}, T) :-
    !type[occ, T] in s.

rules declareVar : scope * ID * TYPE
  declareVar(s, decl, T) :-
    declareVarOccurrence(s, Var{decl@decl}, T).

rules resolveVar : scope * ID -> list(DECL)
  resolveVar(s, name) = ps :-
    query type
      filter P*
      and { d' :- d' == Var{name@_} }
      min $ < P
      in s |-> ps.

rules typeOfVar : scope * ID -> TYPE
  typeOfVar(s, name) = T :- {decl}
    resolveVar(s, name) == [(_, (decl, T))|_].

// Types
rules typeOfType : scope * Type -> TYPE
  typeOfType(s, t@IntType())    = INT().
  typeOfType(s, t@BoolType())   = BOOL().
  typeOfType(s, t@ObjectType()) = OBJECT().
  typeOfType(s, t@VoidType())   = VOID().

  typeOfType(s, t@ClassType(name)) = T :-
    typeOfClass(s, name) == T@CLASS(_, _).

rules lub : TYPE * TYPE -> TYPE
  lub(T@CLASS(_, _), NULL())    = T.
  lub(NULL(), T@CLASS(_, _))    = T.
  lub(T,      T)                = T.

rules assignableTo : TYPE * TYPE
  assignableTo(T, T).
  assignableTo(NULL(),    T@CLASS(_, _)).

// Complex Resolution
rules typeOfVarMemberClass : scope * ID -> TYPE
  typeOfVarMemberClass(s, name) = T :- {decl}
    // resolution order:
    // 1. variables
    // 2. member
    // 3. type
    resolveVarMemberClass(s, name) == [(_, (decl, T))|_].

rules resolveVarMemberClass : scope * ID -> list(DECL)
  resolveVarMemberClass(s, name)
    = unwrapVarMemberClass(s, name, resolveVar(s, name)).

rules unwrapVarMemberClass : scope * ID * list(DECL) -> list(DECL)
  unwrapVarMemberClass(_, _, ps@[(_, (Var{decl@_}, T))|_]) = ps.
  unwrapVarMemberClass(s, name, []) = resolveMemberClass(s, name).

rules resolveMemberClass : scope * ID -> list(DECL)
  resolveMemberClass(s, name)
    = unwrapMemberClass(s, name, resolveMember(s, name)).

rules unwrapMemberClass : scope * ID * list(DECL) -> list(DECL)
  unwrapMemberClass(_, _, ps@[(_, (Member{decl@_}, T))|_]) = ps.
  unwrapMemberClass(s, name, []) = resolveClass(s, name).

// Placeholders
rules
  programOk(Start-Plhdr()).
  classOk(_, ClassDecl-Plhdr()).
  memberOk(_, MemberDecl-Plhdr()).
  typeOfParam(_, ParamDecl-Plhdr()) = _.
  stmtOk(_, Stmt-Plhdr()).
  typeOfExp(_, Exp-Plhdr()) = _.
  typeOfRef(_, Ref-Plhdr()) = _.
  typeOfCall(_, Exp-Plhdr()) = _.
  typeOfNew(_, Exp-Plhdr()) = _.
  typeOfType(_, Type-Plhdr()) = _.
